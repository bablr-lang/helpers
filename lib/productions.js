/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./productions.macro.js#ab30a55dff3676ff2418023be450dabe54386ee0
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { interpolateArray as _interpolateArray, interpolateArrayChildren as _interpolateArrayChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
export function* List({
  value: props,
  ctx
}) {
  const {
    element,
    separator,
    allowHoles = false,
    allowTrailingSeparator = true
  } = ctx.unbox(props);
  yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [_t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
      }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
        content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
        closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
      }, {})],
      closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {});
  let sep,
    it,
    anySep = false;
  for (;;) {
    it = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(element, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(element)],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (it || allowTrailingSeparator) {
      sep = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(separator, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [..._interpolateArray(separator), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      anySep ||= sep;
    }
    if (!(sep || allowHoles)) break;
  }
}
export function* Any({
  value: matchers,
  ctx
}) {
  for (const matcher of ctx.unbox(matchers)) {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(matcher, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(matcher)],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) break;
  }
}
export function* All({
  value: matchers,
  ctx
}) {
  for (const matcher of ctx.unbox(matchers)) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(matcher, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(matcher)],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
}
export function* Punctuator({
  intrinsicValue
}) {
  if (!intrinsicValue) throw new Error('Intrinsic productions must have value');
  yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(intrinsicValue, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [..._interpolateArray(intrinsicValue)],
      closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {});
}
export const Keyword = Punctuator;
export function* Optional({
  value: matchers,
  ctx
}) {
  const matchers_ = ctx.unbox(matchers);
  if (matchers_.length > 1) {
    throw new Error('Optional only allows one matcher');
  }
  yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(matchers_[0], _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [..._interpolateArray(matchers_[0])],
      closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {});
}